Методы и интерфейсы
Этот урок описывает методы и интерфесы, конструкции, которые определяют объекты и их поведение.

Авторы Go
https://golang.org

* Методы

В Go нет классов.
Однако, вы можете определить методы у типов.

Метод - это функция со специальным аргументом _получатель_.

Получатель указывается в собственном списке аргументов между ключевым словом `func` и
названием метода.

В этом примере, метод `Abs` имеет получателя типа `Vertex`, названного `v`.

.play methods/methods.go

* Методы - это функции

Помните: метод - это функция с получателем.

Здесь `Abs` написана как обычная функция без изменения функциональности.

.play methods/methods-funcs.go

* Методы (продолжение)

Вы можете объявлять методы у неструктурных типов.

В этом примере мы видим числовой тип `MyFloat` с методом `Abs`.

Вы можете объявить метод только с теми типами получателей, которые объялены в том же
пакете, что и метод.
Вы не можете объявить метод с типом получателя, объявленным в другом
пакете (что включает также и встроенные типа, как `int`).

.play methods/methods-continued.go

* Получатели по указателю

Вы можете объявить метод с получателем по указателю.

Это значит, что тип получателя имеет вид `*T` для какого-либо типа `T`.
(Также, `T` не может сам быть указателем, как `*int`.)

Например, метод `Scale` определен у типа `*Vertex`.

Методы с получателями по указателю могут изменять значение, на которое ссылается
получатель (как метод `Scale` делает в данном случае).
Так как методы часто изменяют получателя, получатели по указателю более часты в использовании,
чем получатели по значению.

Попробуйте убрать `*` из объявления функции `Scale` в строке 16
и посмотрите как изменится поведение программы.

С получателем по значению, метод `Scale` работает с копией оригинального значения
`Vertex`.
(Это поведение также распространяется и на другие аргументы функций.)
Метод `Scale` должен иметь получателя по указателю, чтобы изменять значение типа `Vertex`,
объявленное в функции `main`.

.play methods/methods-pointers.go

* Указатели и функции

Здесь мы видим методы `Abs` и `Scale`, переписанные как функции.

Снова, попробуйте удалить `*` из строки 16.
Можете ли вы понять, почему поведение изменилось?
Что еще вы должны поменять в программе, чтобы она скомпилировалась?

(Если вы не уверены, перейдите к следующей странице.)

.play methods/methods-pointers-explained.go

* Методы и разыменовывание указателей

Сравнивая две предыдущие программы, вы могли заметить, что
функции с аргументом по указателю должны получать указатель:

	var v Vertex
	ScaleFunc(v)  // Ошибка компиляции!
	ScaleFunc(&v) // OK

а методы с получателем по указателю могут принимать либо значение, либо указатель в качестве
получателя при вызове:

	var v Vertex
	v.Scale(5)  // OK
	p := &v
	p.Scale(10) // OK

Для выражения `v.Scale(5)`, хотя `v` является значением, а не указателем,
метод с получателем по указателю будет вызван автоматически.
Для удобства, Go интерпретирует выражение `v.Scale(5)` как
`(&v).Scale(5)`, так как метод `Scale` ожидает получателя по указателю.

.play methods/indirection.go

* Методы и разыменовывание указателей (2)

То же самое случается и в обратном порядке.

Функции, которые ожидают значение, должны принимать значение данного конкретного типа:

	var v Vertex
	fmt.Println(AbsFunc(v))  // OK
	fmt.Println(AbsFunc(&v)) // Ошибка компиляции!

а методы с получателем по значению могут принимать либо значение, либо указатель в качестве
получателя при вызове:

	var v Vertex
	fmt.Println(v.Abs()) // OK
	p := &v
	fmt.Println(p.Abs()) // OK

В данном случае, вызов метода `p.Abs()` интерпретируется как `(*p).Abs()`.

.play methods/indirection-values.go

* Выбор между получателем по значению и указателю

Есть две причины, чтобы использовать получатель по указателю.

Первая - методы смогут изменять значение, на которое ссылается получатель.

Вторая - избежать копирования значения при каждом вызове метода.
Это может быть эффективно, если, например, получателем является большая струтура.

В данном примере, `Scale` и `Abs` имеют тип получателя `*Vertex`,
хотя `Abs` не изменяет получателя.

В общем, все методы типа должны иметь либо получателя по значению, либо по указателю,
но не смесь обоих вариантов.
(Вы увидим почему так в следующих уроках.)

.play methods/methods-with-pointer-receivers.go

* Интерфейсы

_Интерфейс_ определяется как набор определений методов.

Значение интерфейса может содержать любое значение, которое реализует эти методы.

*Замечание:* В данном примере ошибка в строке 22.
`Vertex` (тип-значение) не реализует интерфейс `Abser`, так как
метод `Abs` определен только у `*Vertex` (тип-указатель).

.play methods/interfaces.go

* Интерфейсы реализуются неявно

Тип релизует интерфейс через реализацию его методов.
Здесь нет явного объявления реализации через ключевое слово "implements".

Неявные интерфейсы разъединяют определение интерфейса от его
реализации, которая может быть в любом пакете.

.play methods/interfaces-are-satisfied-implicitly.go

* Значения интерфейсов

Интерфейсы могут рассматрироваться как кортеж из значения и конкретного типа:

	(value, type)

Значение интерфейса содержит значение конкретного типа.

Вызов метода у значения интерфейса выполняет метод с таким же именем у
его конкретного типа.

.play methods/interface-values.go

* Интерфейсы с внутренними пустыми значениями

Если конкретное значение внутри интерфейса является `nil`,
то метод будет вызван с nil-получателем.

В некоторых языках это спровоцирует ошибку нулевого указателя,
но в Go вы можете писать методы, которые будут работать даже при вызове
с нулевым получателем (как метод `M` в примере.)

Обратите внимание, что значение интерфейса, который содержит конкретное значение nil, само по себе не nil.

.play methods/interface-values-with-nil.go

* Нулевой интерфейс

Нулевой интерфейс не содержит ни значения, ни конкретного типа.

Вызов метода у нулевого указателя спровоцирует ошибку времени выполнения, так как
внутри интерфейса нет конкретного типа, чтобы узнать, какой _конкретный_ метод надо вызвать.

.play methods/nil-interface-values.go

* Пустой интерфейс

Интерфейс, которые не определяет ни одного метода, также известен как _пустой_интерфейс_:

	interface{}

Пустой интерфейс может содержать значение любого типа.
(Любой тип реализует по крайней мере 0 методов.)

Пустые интерфейсы используются при обработке значений неизвестного типа.
Например, `fmt.Print` принимает любой число аргументов типа `interface{}`.

.play methods/empty-interface.go

* Проверка типов

_Проверка_типов_ предоставляет доступ к конкретному внутреннему значению интерфейса.

	t := i.(T)

Это выражение проверяет, что интерфейс `i` содержит конкретный тип `T`
и присваивает внутреннее значение типа `T` переменной `t`.

Если `i` не содержит тип `T`, выражение вызовет ошибку.

Чтобы _проверить_, содержит ли  интерфейс значение конкретного типа,
проверка типа может вернуть два значения: внутренне значение
и булево значение, которое сообщает, успешна ли проверка.

	t, ok := i.(T)

Если `i` содержит тип `T`, то `t` будет внутренним значением и `ok` будет `true`.

Если нет, то `ok` будет `false` и `t` будет значением по умолчанию для типа `T`,
причем не будет ошибок.

Заметьте схожесть этого систаксиса с получением элемента из словаря.

.play methods/type-assertions.go

* Switch по типу

_Switch_по_типу_ является конструкцией, которая позволяет проводить несколько проверок типов подряд.

Switch по типу похож на обычную конструкцию switch, но case-случаи в switch-e по типу
определяют типы (не значения), и они сравниваются с
типом значения, которое содержит интерфейс.

	switch v := i.(type) {
	case T:
		// здесь v имеет тип T
	case S:
		// здесь v имеет тип S
	default:
		// нет совпадений; здесь v имеет тот же тип, что и i
	}

Объявление switch-а по типа имеет тот же синтакс, как и проверка типа `i.(T)`,
но конкретный тип `T` заменен ключевым словом `type`.

Эта switch конструкция проверяет, содержит ли интерфейс `i`
значение типа `T` или `S`.
В каждом из случаев `T` и `S`, переменная `v` будет типа
`T` или `S` соответственно и иметь значение как и у интерфейса `i`.
В случае default (когда не было совпадений), переменная `v` будет
будет такого же типа интерфейса и значения, как и `i`.

.play methods/type-switches.go

* Stringers

Один из самых вездесущих интерфейсов - [[//golang.org/pkg/fmt/#Stringer][`Stringer`]], определенный в пакете [[//golang.org/pkg/fmt/][`fmt`]].

	type Stringer interface {
		String() string
	}

`Stringer` является типом, которым может описать себя строкой. Пакет `fmt`
(и многие другие) используют этот интерфейс при выводе значений.

.play methods/stringer.go

* Упражнение: Stringers

Сделайте так, чтобы тип `IPAddr` реализовывал интерфейс `fmt.Stringer` для вывода IP-адреса
как четыре числа, разделенных точкой.

Например, `IPAddr{1,`2,`3,`4}` должно вывести `"1.2.3.4"`.

.play methods/exercise-stringer.go

* Ошибки

Программы на Go выражают состояние ошибки через значения `error`.

Тип `error` является встроенным интерфейсом, как и `fmt.Stringer`:

	type error interface {
		Error() string
	}

(Как и с `fmt.Stringer`, пакет `fmt` использует интерфейс `error` при выводе значений.)

Функции часто возвращают значение типа `error`, и вызывающий код должен обрабатывать ошибки
проверкой того, является ли ошибка нулевой(`nil`) или нет.

	i, err := strconv.Atoi("42")
	if err != nil {
		fmt.Printf("couldn't convert number: %v\n", err)
		return
	}
	fmt.Println("Converted integer:", i)

Нулевая ошибка обозначает успех; ненулевая ошибка обозначает неудачу.

.play methods/errors.go

* Упражнение: Ошибки

Скопируйте вашу фукнцию `Sqrt` с [[/flowcontrol/8][предыдущего упражнения]] и измените её, чтобы она возвращала значение `error`.

`Sqrt` должна возвращает ненулевую ошибку если было передано отрицательное число, так как функция не поддерживает комплексные числа.

Создайте новый тип

	type ErrNegativeSqrt float64

и реализуйте интерфейс `error` через реализизацию

	func (e ErrNegativeSqrt) Error() string

метода так, чтобы `ErrNegativeSqrt(-2).Error()` возвращало `"cannot`Sqrt`negative`number:`-2"`.

*Замечание:* вызов `fmt.Sprint(e)` внутри метода `Error` отправит программу в бесконечный цикл. Вы можете избежать этого, сначала сконверитровав `e`: `fmt.Sprint(float64(e))`. Почему?

Измените вашу функцию `Sqrt`, чтобы она возвращала значение `ErrNegativeSqrt`, если ей передать отрицательное число.

.play methods/exercise-errors.go

* Readers

Пакет `io` определяет интерфейс `io.Reader`,
который представляет считывание данных по конца потока.

Стандартная библиотека Go содержит [[https://golang.org/search?q=Read#Global][много реализаций]] этого интерфейса, включая файлы, сетевые соединения, компрессоры, шифраторы и другое.

Интерфейс `io.Reader` имеет метод `Read`:

	func (T) Read(b []byte) (n int, err error)

`Read` заполняет данный слайс из байтов данными, возвращает число считанных
байтов и значение ошибки. Метод возвращает ошибку `io.EOF` если поток
закончился.

Данный пример создает
[[//golang.org/pkg/strings/#Reader][`strings.Reader`]]
и потребляет его вывод по 8 байт за один раз.

.play methods/reader.go

* Упражнение: Readers

Реализуйте тип `Reader`, который производит бесконечный поток ASCII-символа
`'A'`.

.play methods/exercise-reader.go

* Упражнение: rot13Reader

Часто используемый паттерн, когда [[https://golang.org/pkg/io/#Reader][io.Reader]] которые оборачивает другой `io.Reader`, изменяя поток каким-либо образом.

Например, функция [[https://golang.org/pkg/compress/gzip/#NewReader][gzip.NewReader]] принимает `io.Reader` (поток сжатых данных) и возвращает `*gzip.Reader`, который тоже реализует `io.Reader` (поток разархивированных данных).

Реализуйте `rot13Reader`, который реализует `io.Reader` и считывает данные с `io.Reader`, изменяет поток, применяя шифр [[https://en.wikipedia.org/wiki/ROT13][rot13]] для всех алфавитных символов.

Тип `rot13Reader` предоставлен вам.
Реализуйте интерфейс `io.Reader` через реализацию метода `Read`.

.play methods/exercise-rot-reader.go

* Изображения

[[https://golang.org/pkg/image/#Image][Пакет image]] определяет интерфейс `Image`:

	package image

	type Image interface {
		ColorModel() color.Model
		Bounds() Rectangle
		At(x, y int) color.Color
	}

*Замечание*: возвращаемое значение `Rectangle` у метода `Bounds` на самом деле является
[[https://golang.org/pkg/image/#Rectangle][`image.Rectangle`]], так как определение происходит
внутри пакета `image`.

(Смотрите [[https://golang.org/pkg/image/#Image][документацию]] для деталей.)

Типы `color.Color` и `color.Model` также являются интерфейсами, но мы будем использовать готовые реализации `color.RGBA` и `color.RGBAModel`. Эти интерфейсы и типы определены в пакете [[https://golang.org/pkg/image/color/][image/color]]

.play methods/images.go

* Упражнение: Изображения

Помните генератор картинки, который вы писали ранее? Давайте напишем еще один, но в этот раз он вернет реализацию `image.Image` вместо слайса данных.

Определите ваш собственный тип `Image`, реализуйте [[https://golang.org/pkg/image/#Image][необходимые методы]], и вызовите `pic.ShowImage`.

Метод `Bounds` должен возвращать `image.Rectangle`, например `image.Rect(0,`0,`w,`h)`.

Метод `ColorModel` должен возвращать `color.RGBAModel`.

Метод `At` должен возвращать цвет; значение `v` в предыдущем генераторе соответствует значению `color.RGBA{v,`v,`255,`255}` в новом.

.play methods/exercise-images.go

* Поздравления!

Вы закончили этот урок!

Вы можете вернуться к списку модулей [[/list][modules]], или перейти к [[javascript:click('.next-page')][следующему уроку]].
