Управляющие операторы: for, if, else, switch и defer
Узнайте, как контролировать выполнение кода с помощью условий, циклов, переключателей и отложенных вызовов.

Авторы Go
https://golang.org

* For

В Go есть только одна конструкция для цикла, `for`.

Простой цикл `for` состоит из трех компонент, разделенных точкой с запятой:

- инициализация: выполняется перед первой итерацией
- условие: выполняется перед каждой итерацией
- пост-выражение: выполняется после каждой итерации

Инициализация обычно является коротким объявлением переменной,
которая будет доступна только в области цикла `for`.

Цикл прекращает выполнение, когда условие становится `false`.

_Note_: В отличие от других языков, как C, Java, или Javascript, здесь нет круглых скобок,
обрамляющих три компоненты цикла `for`, а фигурные скобки `{`}` всегда обязательны.

.play flowcontrol/for.go

* For (продолжение)

Инициализация и пост-выражение являются опциональными.

.play flowcontrol/for-continued.go

* For в качестве "while" в Go

Вы можете убрать точки с запятой и получите аналог цикла `while` в C.

.play flowcontrol/for-is-gos-while.go

* Бесконечный цикл

Если вы опустите условие цикла, то цикл будет выполнятся бесконечно

.play flowcontrol/forever.go

* If

В Go оператор `if` похож на цикл `for`; выражение не должно быть
обрамлено круглыми скобками `(`)`, но фигурные скобки `{`}` обязательны.

.play flowcontrol/if.go

* If с коротким выражением

Как и `for`, оператор `if` может начинаться с короткого выражения, которое будет выполнено перед условием.

Переменные, объявленные в выражении могут использоваться только внутри области `if`.

(Попробуйте использовать `v` в последнем операторе `return`.)

.play flowcontrol/if-with-a-short-statement.go

* If и else

Переменные, объявленные в коротких выражениях оператора `if`, также доступны внутри любого блока `else`.

(Оба вызова `pow` будут выполнены и возвращены перед вызовом функцией `main` функции `fmt.Println`.)

.play flowcontrol/if-and-else.go

* Упражнение: Циклы и Функции

В качестве упражнения, реализуйте функция нахождения квадратного корня, используя метод Ньютона.

В данном случае, метод Ньютона вычисляет `Sqrt(x)`, беря начальную точку _z_ и повторяя следующий шаг:

.image /content/img/newton.png

Для начала, повторите вычисления 10 раз и посмотрите, насколько точен ваш ответ для разных чисел (1, 2, 3, ...).

Затем сделайте так, чтобы цикл прекразал выполнение, если значение перестало меняться (или изменение очень незначительное).
Посмотрите, сколько требуется итераций, больше или меньше. Как близко вы к [[https://golang.org/pkg/math/#Sqrt][math.Sqrt]]?

Подсказка: чтобы объявить и инициализировать значение с плавающей точкой, используйте синтакс плавающей точки или используйте приведение типа:

	z := float64(1)
	z := 1.0

.play flowcontrol/exercise-loops-and-functions.go

* Switch

Вы наверное знаете, как выглядит `switch`.

Тело `case` прекращает выполнение автоматически, если только оно не заканчивается оператором `fallthrough`.

.play flowcontrol/switch.go

* Порядок выполнения Switch

Switch выполняет `case`-условия сверху вниз, останавливаясь на первом успешном `case`.

(Например,

	switch i {
	case 0:
	case f():
	}

не вызовет `f` если `i==0`.)

#appengine: *Замечание:* Время в "Go playground" всегда начинается с
#appengine: 2009-11-10 23:00:00 UTC. Определение значимости этого значения
#appengine: оставим читателю.

.play flowcontrol/switch-evaluation-order.go

* Switch без выражения

Switch без выражения является аналогом `switch`true`.

Это может быть полезно при написании длинных if-then-else цепочек.

.play flowcontrol/switch-with-no-condition.go

* Defer

Инструкция отложенного вызова `defer` откладывает выполнение функции до тех пор, пока текущая
функция не завершится.

Аргументы отложенной функции вычисляется немедленно, но вызов функции
не происходит до тех пор, пока текущая функция не завершится.

.play flowcontrol/defer.go

* Стэк отложенных вызовов

Отложенные вызовы складываются в стэк. Когда функция завершается,
отложенные вызовы выполняется в порядке LIFO(last-in-first-out).

Чтобы узнать больше об отложенных вызовах, прочитайте этот
[[https://blog.golang.org/defer-panic-and-recover][пост]].

.play flowcontrol/defer-multi.go

* Поздравления!

Вы закончили этот урок!

Вы можете вернуться к списку модулей [[/list][modules]], или перейти к [[javascript:click('.next-page')][следующему уроку]].
