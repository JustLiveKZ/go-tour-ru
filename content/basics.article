Пакеты, переменные и функции.
Учим основные компоненты любой программы на языке Go.

Авторы языка Go
https://golang.org

* Пакеты

Каждая программа на языке Go состоит из пакетов.

Программа начинает выполнение в пакете `main`.

Эта программа использует пакеты с путями импорта `"fmt"` и `"math/rand"`.

По соглашению, имя пакета совпадает с последним элеметов пути импорта. Например, пакет `"math/rand"` включает файлы,
которые начинаются с инструкции `package`rand`.

#appengine: *Замечание:* окружение, в котором выполняются программы является
#appengine: детерминированным, поэтому каждый раз при запуске этой программы
#appengine: `rand.Intn` будет возвращать одно и то же число.
#appengine:
#appengine: (Чтобы увидеть другое число, задайте числовой генератор;
подробнее [[https://golang.org/pkg/math/rand/#Seed][`rand.Seed`]].)

.play basics/packages.go

* Импорты

Этот код оборачивает импорты в скобки, так называемый "факторный (factored)" импорт.

Вы также можете написать несколько инструкций импорта, например:

	import "fmt"
	import "math"

Но хорошим стилем считается использование факторного испорта.

.play basics/imports.go

* Экспортируемые имена

В Go, имя экспортируется, если оно начинается с заглавной буквы.

При импорте пакеты, вы можете обращаться только в экспортируемым именам.
Любые "неэкспортируемые" имена недоступны вне пакета.

`Pi` является экспортируемым именем, как и `PI`. Но имя `pi` не является экспортируемым.

Запустить код. Прочтите сообщение об ошибке.

Чтобы исправить ошибку, переименуте `math.pi` в `math.Pi` и попробуйте снова.

.play basics/exported-names.go

* Функции

Функции могут принимать ноль или более аргументов.

В этом примере функция `add` принимает 2 аргумента типа `int`.

Заметьте, что тип указывается _после_ имени переменной.

(Чтобы узнать больше о типах и почему они так выглядят, смотрите
[[https://blog.golang.org/gos-declaration-syntax][статью о синтаксисе деклараций в Go]].)

.play basics/functions.go

* Функции (продолжение)

Когда два или более последовательных аргумента функции имеют одинаковый тип, вы можете опустить тип у всех аргументов
кроме последнего.

В этом примере мы сократили

	x int, y int

до

	x, y int

.play basics/functions-continued.go

* Множественные возвращаемые значения

Функция может вернуть любой количество значений.

Функция `swap` возвращает две строки.

.play basics/multiple-results.go

* Именованые возвращаемые значения

В Go возвращаемые значения могут быть именоваными. В этом случае, они рассматирваются как переменные,
определенные приобъявление фукнции.

Эти имена должны использоваться для определения смысла возвращаемых значений.

Инструкция `return` без аргументов возвращает именованые значения. Это также известно, как "голый" возврат.

Голые возвраты должны использоваться только в коротких функциях, как в примере.
Они могут ухудшить читаемость в длинных функциях.

.play basics/named-results.go

* Переменные

Инструкция `var` объявляет список переменных; тип указывается в конце, как и в аргументах функции.

Инструкция `var` может быть на уровне пакета или функции. Мы видим оба варианта на примере.

.play basics/variables.go

* Переменные с инициализаторами

Объявление переменной может включать инициализаторы, один на каждую переменную

Если инициализотор представлен, тип может быть опущен; переменная возьмет тип инициализатора

.play basics/variables-with-initializers.go

* Сокращенное объявление переменных

Внутри функции может быть использована сокращенная инструкция присваивания `:=` вместо инструкции `var` с неявным типом.

Вне функции, каждая инструкция начинается с ключевого слова (`var`, `func` и др.), поэтому вне функции инструкция `:=`
недоступна.

.play basics/short-variable-declarations.go

* Основные типы

Основные типы в Go

	bool

	string

	int  int8  int16  int32  int64
	uint uint8 uint16 uint32 uint64 uintptr

	byte // синоним для uint8

	rune // синоним для int32
	     // представляет символ Unicode

	float32 float64

	complex64 complex128

Пример показывает переменные разных типов,
а также то, что объявление переменных может быть "сложено" в блоки,
как и инструкции импорта.

Типы `int`, `uint`, и `uintptr` обычно занимают 32 бита на 32-битных системах и 64 бита на 64-битных системах.
Если вам нужна переменная целого типа, вы должны использовать тип `int`,
если у вас нет специфичных причин на использование целочисленных типов другого размера или беззнаковых целочисленных
типов.

.play basics/basic-types.go

* Значению по умолчанию

Переменные, объявленные без явного начального значению будут проинициализированы _значениями_по_умолчанию_

Значения по умолчанию:

- `0` для числовых типов,
- `false` для булевого типа, и
- `""` (пустая строка) для строк.

.play basics/zero.go

* Преобразование типов

Выражение `T(v)` преобразует значение `v` в тип `T`.

Несколько числовых преобразований типов:

	var i int = 42
	var f float64 = float64(i)
	var u uint = uint(f)

Или, в сокращенной записи:

	i := 42
	f := float64(i)
	u := uint(f)

В отличие от C, в Go присвоения между элементами разного типа требуют
явного преобразования типов.
Попробуйте убрать преобразования `float64` или `uint` в примере и посмотрите что случится.

.play basics/type-conversions.go

* Назначение типов

При объявлении переменной без явного указания типа (с использованием синтаксиса `:=` или синтаксиса `var`=`),
тип переменной определяется по значению с правой части.

Если с правой стороны типизированное значение, то новая переменная будет иметь тот же тип:

	var i int
	j := i // j будет иметь тип int

Но если с правой стороны содержится нетипизированная числовая константа, новая переменная может быть типа
`int`, `float64`, или `complex128`, в зависимости от точности константы:

	i := 42           // int
	f := 3.142        // float64
	g := 0.867 + 0.5i // complex128

Попробуйте изменить начальное значение переменной `v` в примере и посмотрите как изменится тип.

.play basics/type-inference.go

* Константы

Константы объявляются как переменные, но с ключевым словом `const`.

Константы могут быть символьным, стороковым, булевым или числовым значением.

Константы не могут быть объявлены с использованием сокращенного `:=` синтаксиса.

.play basics/constants.go

* Числовые константы

Числовые константы является _значениями_ с высокой точностью.

Нетипизованные константы принимают тип в зависимости от контекста.

Попробуйте напечатать `needInt(Big)`.

(Тип `int` может хранить максимум 64-битное целое число, а иногда меньше.)

.play basics/numeric-constants.go

* Поздравления!

Вы закончили этот урок!

Вы можете вернуться к списку модулей [[/list][modules]]
или перейти к [[javascript:click('.next-page')][следующему уроку]].
