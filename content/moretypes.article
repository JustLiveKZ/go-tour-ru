Больше типов: структуры, слайсы и словари.
Узнайте как определять типы, используя существующие: этот урок затрагивает структуры, массивы, слайсы и словари.

Авторы Go
https://golang.org

* Указатели

В Go есть указатели.
Указатель хранит адрес переменной в памяти.

Тип `*T` является указателем на значение типа `T`. Значение по умолчанию `nil`.

	var p *int

Оператор `&` возвращает указатель на его операнд.

	i := 42
	p = &i

Оператор `*` получает значение, на которое ссылается указатель.

	fmt.Println(*p) // считывает i через указатель p
	*p = 21         // меняет i через указатель p

Это также известно, как "разыменовывание".

В отличие от C, в Go над указателями нельзя проводить арифметические операции (например посчитать разницу между указателями).

.play moretypes/pointers.go

* Структуры

`struct` является коллекцией полей.

(И объявление `type` делает то, что вы ожидаете.)

.play moretypes/structs.go

* Поля структуры

Доступ к полям структуры осуществляется через точку.

.play moretypes/struct-fields.go

* Указатели на структуры

Поля структуры также доступны через указатель на структуру.

Разыменовывание указателя происходит неявно.

.play moretypes/struct-pointers.go

* Структурные литералы

Структурный литерал используется для инициализации полей в только что созданной структуре.

Вы можете перечислить лишь некоторые поля используя синтакс `Name:`. (Порядок именованых полей не имеет значения.)

Специальных префикс `&` возвращает указатель на структуру.

.play moretypes/struct-literals.go

* Массивы

Тип `[n]T` обозначает массив из `n` элементов типа `T`.

Выражение

	var a [10]int

объявляет переменную `a` как массив из десяти целых чисел.

Длина массива является частью типа, поэтому размер массива не может быть изменен.
Это кажется ограничением, но не беспокойтесь;
Go предоставляет удобный способ работы с массивами.

.play moretypes/array.go

* Слайс

Слайс указывает на массив значений и также включает длину.

`[]T` является слайсом из элементов типа `T`.

`len(s)` возвращает длину слайса `s`.

.play moretypes/slices.go

* Слайсы слайсов

Слайсы могут содержать значения любого типа, включая другие слайсы.

.play moretypes/slices-of-slice.go

* Слайсинг слайсов

Слайсы могут быть обрезаны (это называется слайсинг(slicing)), при этом создается новый слайс, который указывает на тот же массив.

Выражение

	s[lo:hi]

является слайсом всех элементов с позиции `lo` до `hi-1`, включительно. Поэтому

	s[lo:lo]

является пустым слайсом, а

	s[lo:lo+1]

является слайсом из одного элемента.

.play moretypes/slicing-slices.go

* Создание слайсов

Слайсы создаются с помощью функции `make`. При этом создается массив со значениями по умолчанию и возвращается слайс, который указывает на этот массив:

	a := make([]int, 5)  // len(a)=5

Чтобы указать вместимость, передайте третий аргумент в функцию `make`:

	b := make([]int, 0, 5) // len(b)=0, cap(b)=5

	b = b[:cap(b)] // len(b)=5, cap(b)=5
	b = b[1:]      // len(b)=4, cap(b)=4

.play moretypes/making-slices.go

* Нулевой слайсы

Значением по умолчанию для слайса является `nil`.

Нулевой слайс имеет длину и вместимость равную 0.

.play moretypes/nil-slices.go

* Добавление элементов в слайс

Часто вам понадобится добавлять новые элементы в слайс, поэтому в Go есть встроенная
функция `append`. [[https://golang.org/pkg/builtin/#append][Документация]]
встроенного пакета описывает `append`.

	func append(s []T, vs ...T) []T

Первый агрумент `s` в функции `append` является слайсом типа `T`, остальные аргументы
является значениями типа `T`, которые нужно добавить в слайс.

Результатом функции `append` является слайс, содержащий все элементы
первоначального слайса и переданные значения.

Если массив, на который указывает слайс `s`, слишком мал, чтобы вместить все переданные значения, будет создан
новый массив с большим размером. Возращенный слайс будет указывать на только что созданный
массив.

(Чтобы узнать больше о слайсах, прочтите статью [[https://blog.golang.org/go-slices-usage-and-internals][Слайсы: использование и внутреннее строение]].)

.play moretypes/append.go

* Range

Форма `range` цикла `for` итерирует слайс или словарь.

При итерации слайса, на каждой итерации будет возвращаться два значения.
Первое значение - индекс, второе значение - копия элемента по этому индексу.

.play moretypes/range.go

* Range (продолжение)

Вы можете пропустить индекс или значение, присвоив их переменной `_`.

Если вам нужен только индекс, удалите ", value" полностью.

.play moretypes/range-continued.go

* Упражнение: Слайсы

Реализуйте функцию `Pic`. Она должна возвращать слайс длины `dy`, каждый элемент которого также является слайсом длины `dx`, содержащим 8-битные беззнаковые целые числа.
Когда вы запустите программу, она отобразит вашу картинку, сопоставляя числам оттенки серого (хорошо, синего) цвета.

Выбор картинки за вами. Интересные функции: `(x+y)/2`, `x*y`, и `x^y`.

(Вы должны использовать цикл, чтобы создать `[]uint8` внутри `[][]uint8`.)

(Исползуйте `uint8(intValue)` для конвертации между типами.)

.play moretypes/exercise-slices.go

* Словари

Словарь сопоставляет ключам значения.

Словари должны создаваться с помощью `make` до использования; словарь `nil` является пустым и не может содержать значений.

.play moretypes/maps.go

* Словарные литералы

Словарные литералы похожи на структурные литералы, но ключи обязательны.

.play moretypes/map-literals.go

* Словарные литералы (продолжение)

Если верхний типа является названием типа, вы можете исключить его из элементов литерала.

.play moretypes/map-literals-continued.go

* Изменение словарей

Добавление или изменение элемента в словаре `m`:

	m[key] = elem

Получение элемента:

	elem = m[key]

Удаление элемента:

	delete(m, key)

Проверка того, что ключ существует, с использованием присваивания двум значениям:

	elem, ok = m[key]

Если `key` существует в `m`, `ok` будет `true`. Если нет, `ok` будет `false`.

Если `key` не существует в словаре, тогда `elem` является значением по умолчанию для типа, элементы которого хранит словарь.

_Замечание_: если `elem` или `ok` были не объявлены, вы можете использовать форму короткого объявления:

	elem, ok := m[key]

.play moretypes/mutating-maps.go

* Упражнение: Словари

Реализуйте функцию `WordCount`. Она должна возвращать словарь с количеством каждого слова “word” в строке `s`. Функция `wc.Test` запускает тест для проверки вашей функции и выводит сообщение об успехе или ошибке.

[[https://golang.org/pkg/strings/#Fields][strings.Fields]] может быть полезным для вас.

.play moretypes/exercise-maps.go

* Функции как значения

Функции также являются значениями. Они могут быть использованы как и другие значения.

Функции могут передаваться в другие функции как аргументы, а также быть возвращаемым значением функции.

.play moretypes/function-values.go

* Замыкания

В Go функции могут быть замыканиями. Замыкание - это функция, которая обращается к переменным вне своей области видимости. Функция может иметь доступ и изменять значения этих переменных; в этом случае функция "связана" с переменными.

Например, функция `adder` возвращает замыкание. Каждой замыкание связано с собственной переменной `sum`.

.play moretypes/function-closures.go

* Упражнение: Числа Фибоначчи

Давайте получим удовольствие от работы с функциями.

Реализуйте функцию `fibonacci`, которая возвращает фукнцию (замыкание), которая
возвращает последовательные [[https://en.wikipedia.org/wiki/Fibonacci_number][числа Фибоначчи]]
(0, 1, 1, 2, 3, 5, ...).

.play moretypes/exercise-fibonacci-closure.go

* Поздравления!

Вы закончили этот урок!

Вы можете вернуться к списку модулей [[/list][modules]], или перейти к [[javascript:click('.next-page')][следующему уроку]].
